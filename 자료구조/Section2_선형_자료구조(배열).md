# Section2. 선형 자료구조(배열)
## 0. 자료의 저장 방식
그림속 오타 수정 (10 -> 6)
![dataSave](https://github.com/CodeWave-Summer-Edition/CSMaster/assets/43038815/7309d9bb-a293-4c9c-a849-8b51ec281df8)

## 1. 배열
**데이터를 효율적으로 관리하기 위해 유사한 데이터를 인접한 메모리에 순차적으로 저장하는 자료구조**
### 특징
- 배열은 고정된 크기로 할당이 된다. (한번 할당된 배열의 크기를 늘릴 수 없다.)
- 연속적으로 인접한 메모리에 데이터가 저장된다.
- 인덱스를 통해 랜덤 접근(직접 접근)이 가능하다.
- 배열의 이름은 할당받은 공간의 시작 주소이다.

### 배열 할당 및 랜덤 접근 예시
```c
#include <stdio.h>

int main(int argc, char* argv[]) {
	int n = 5;
	int array[n];
	printf("배열의 이름 = %p\n",array);
	for(int i=0;i<n;i++){
		printf("%d 번째 주소 = %p\n",i,&array[i]);
	}
	
	printf("3번째로 직접 접근 = %p\n",array+3);
	
	return 0;
}
```
### 결과
![image](https://github.com/CodeWave-Summer-Edition/CSMaster/assets/43038815/4da4d82b-b571-4979-b58f-4559d43445b1)

### 배열에서의 시간복잡도
- 접근 `O(1)`
    - 직접 접근이 가능하기 때문에, 몇번째 인덱스인지 알면 계산을 통해 상수시간에 접근 가능.
- 탐색 `O(n)`
    - 특정 데이터를 찾기 위해서는 최악의 경우 n개의 데이터를 모두 검사해야하기 때문에 O(n)이 된다.
- 삽입 `O(n)`
    - 연속적으로 저장되는 자료구조기 때문에 배열안에 존재하는 위치에 삽입 시, 뒤의 데이터를 한칸씩 뒤로 Shift하는 과정으로 인해 O(n)이 걸림.
- 삭제 `O(n)`
    - 연속적으로 저장되는 자료구조기 때문에 배열안에 존재하는 위치의 데이터를 삭제시, 뒤의 데이터를 모두 앞으로 한칸씩 Shift하는 과정으로 인해 O(n)이 걸림.

## 2. 리스트
**데이터를 효율적으로 관리하기 위해 유사한 데이터들을 연결을 이용한 논리적 연결을 통해 저장하는 자료구조**
### 특징
- 리스트는 크기가 고정되어있지 않다.
- 인접한 메모리가 아닌, 논리적인 연결을 통해 순차적으로 데이터를 저장한다.
- 인접한 메모리가 아니기 때문에, 랜덤 접근(직접 접근)이 불가능하고, 순차접근이 가능하다.
- 종류로는 단일 연결 리스트, 양방향 연결 리스트, 원형 양방향 연결 리스트가 있다.

### 리스트 할당 및 순차 접근 예시
```cpp
#include <list>
#include <stdio.h>

int main() {
    std::list<int> myList;
    int n = 5;

	myList.assign(n,0);
    printf("myList의 주소: %p\n", &myList);

    // 리스트의 각 요소의 주소 출력
    int index = 0;
    for(std::list<int>::iterator it = myList.begin(); it != myList.end(); ++it, ++index) {
        printf("노드 %d의 주소: %p\n", index, &(*it));
    }

    return 0;
}
```

### 결과
![image](https://github.com/CodeWave-Summer-Edition/CSMaster/assets/43038815/8534dee5-bdce-41f3-ab99-49ec071053bd)

### 리스트의 시간 복잡도
- 접근 `O(n)`
    - 직접 접근이 불가능하기 때문에, head 노드에서부터 순차적으로 접근해야함
- 탐색 `O(n)`
    - 배열과 같이 모든 리스트의 노드에 접근하여 검사해야함
- 삽입 `O(1)`
    - 논리적인 연결고리를 수정하면 되기 때문에 상수시간에 가능
    - 하지만 "X번째에 원소를 삽입" 와 같은 경우, 해당 위치의 노드까지 탐색한 뒤 삽입해야하기 때문에 O(n)이 됨
- 삭제 `O(1)`
    - 논리적인 연결고리를 수정하면 되기 때문에 상수시간에 가능
    - 하지만 삽입과 마찬가지로 "X번째 원소를 삭제"와 같은 경우, 해당 위치의 노드까지 탐색한 뒤 삭제해야하기 때문에 O(n)이 됨

## 3. 배열과 리스트의 비교
### 메모리 측면
- 배열은 `(해당 데이터타입의 크기) * N`만큼의 메모리를 할당받아 사용함.
- 리스트는 `(해당 데이터타입의 크기 + (다음 노드의 주소를 저장할 포인터, 구현한 콜렉션에 따른 추가적인 정보)) * N` 만큼의 메모리를 할당받아 사용함.

### 시간복잡도 측면
위의 설명과 같음

## ArrayList와 LinkedList
**List의 구현체**
### LinkedList
위에 설명한 List의 개념과 동일하게 노드간 연결을 이용한 List 자료구조의 구현체

### ArrayList
List처럼 사용하기 위해 내부적으로 배열을 사용한 List자료구조의 구현체
