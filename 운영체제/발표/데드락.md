## 개요

멀티프로세스, 멀티스레드 환경에서 Race Condition이 발생할 수 있다.

이를 해결하기 위한 방법으로 Lock을 사용한다.

하지만 Lock은 성능 저하와 Deadlock 문제를 수반한다.

해결책은?


## 경쟁 상태(Race Condition)

> 공유 데이터를 여러 주체가 동시에 접근할 때 생기는 문제
> 

ex) OS에서의 Race Condition


1. process A가 kernel mode를 수행 중인 상황에서 context switching 발생
2. process B가 kernel mode를 수행하며 kernel data를 조작
3. 문제 발생!

공유 데이터에 접근하는 코드 → **Critical Section**


## Mutex

> 상호 배제(Mutual Exclusion)
> 

Critical Section에 동시에 접근하지 못하도록 막는 방법

- lock
- unlock

두 가지 연산을 사용하여 구현한다.

## Semaphore

> 정수 변수(세마포어)를 활용하여 일반화된 Mutex를 구현
> 
- P 연산: 자원을 획득 (S값 감소)
- V 연산: 자원을 반납 (S값 증가)

세마포어 값은 원자적으로 제어된다.

S 값이 양수일 때만 P 연산을 통해 자원에 접근한다.

구현 방법

1. Busy Waiting(Spin Lock) → Critical Section의 길이가 매우 짧은 경우에만 효율적
2. Block / Wake up

## Monitor

> 공유 자원 접근 시 High level에서 접근할 수 있도록 도와주는 도구
> 


Semaphore의 경우

- 코딩하기 힘들다
- 정확성 입증이 어렵다
- 구현 시 실수할 가능성이 있다

Monitor의 경우

- 공유 데이터와 연산이 모두 Monitor 내부에 있다
- 모니터 내에서는 한 번에 하나의 프로세스만 실행 가능하다
- condition variable을 사용하여 프로세스들을 제어한다
- condition variable은 wait, signal 연산을 통해 접근 가능하다


## Deadlock

> 프로세스들이 서로가 가진 자원을 기다리며 block된 상태
> 


### Deadlock 발생의 4가지 조건

- Mutual exclusion
    
    하나의 프로세스만이 자원을 사용할 수 있다
    
- No preemption
    
    프로세스는 강제로 자원을 빼앗기지 않는다
    
- Hold and wait
    
    자원을 가진 프로세스가 다른 자원을 기다릴 때 보유 자원을 내놓지 않는다
    
- Circular wait
    
    자원을 기다리는 프로세스들 간에 사이클이 형성되어 있다
    

### 처리 방법

- 데드락 발생 4가지 필요 조건 중 하나를 만족시키지 않도록 한다
- 데드락 회피 → 데드락 가능성이 없을 때만 자원 할당
- 데드락이 발생했을 시 복구한다
- 무시하고 껐다 킨다

### Deadlock Prevention

- 가장 강력한 방법
- Deadlock의 조건 중 하나를 무산시켜서 데드락을 방지
- 데드락을 원천봉쇄 할 수 있지만 비효율적인 측면 존재
1. mutual exclusion은 자원 자체의 성격이기 때문에 무산시킬 수 없다.
2. Hold and wait
    
    → 자원을 요청할 때 가진 자원을 모두 내려 놓고 요청
    
3. No Preemption
    
    → 프로세스가 자원을 기다려야 할 때 이미 보유한 자원을 뺏길 수 있다.
    
    State, context를 쉽게 저장하고 복원할 수 있는 자원에서 사용(한정)
    
4. Circular wait
    
    → 자원의 할당 순서를 정해버림 (배고픈 철학자 문제)
    

### Deadlock Avoidance



- 자원 요청에 대한 추가 정보를 이용해서 데드락을 막는다.
- 프로세스 종료 시 까지 자원을 몇 개 사용할 수 있는지를 알고있다고 가정



자원이 여러 개인 경우 → Banker’s Algorithm

- Max에서 Allocation을 빼서 Need를 계산
- 남아 있는 자원이 있더라도 가용 자원이 최악의 경우(need)를 감당하지 못하면
    
    → 자원을 할당하지 않는다. (보수적)
    
- 안전한 시퀀스가 존재 → safe state

### Deadlock Detection and recovery

- prevention, avoidance는 비효율이 존재한다. → 데드락 발생 여부를 파악하고 처리하는 방법

- 싸이클이 존재(detection) → 데드락

- 가용 자원이 있으면 뒷 일은 생각하지 않고 자원 할당(낙관적)
- 현재가 데드락인지 아닌지를 판단



리커버리 방법

- 프로세스 종료
    - 데드락과 연루된 모든 프로세스를 죽임
    - 데드락과 연루된 프로세스를 하나씩 죽임(잔인)
- 자원을 빼앗는 방법
    - 데드락과 연루된 프로세스(희생양)을 선정
    - starvation문제를 위해 여러 번 victim으로 선정되면 이를 반영


## Application level에서의 일관성, 동시성 제어

*정답은 없다*

데이터의 일관성, 동시성 사이의 Trade off 문제

DBMS 마다 Lock 메커니즘이 다르므로 잘 숙지하고 사용해야 한다.

## 비관적 동시성 제어

- 사용자들이 같은 데이터를 동시에 수정할 것을 가정
- 한 사용자가 데이터를 읽는 시점에 lock을 걸고 조회 or 갱신처리가 완료될 때까지 유지.
- lock은 다른 사용자들이 같은 데이터 수정 못하게 만들어서 비관적 동시성 제어는 잘못사용시 동시성이 나빠진다.
- 비관적 동시성 제어는 자칫 시스템 동시성을 심각하게 떨어뜨릴 우려가 있다
    - FOR UPDATE 에 WAIT 또는 NOWAIT 옵션을 사용
    - 다른 트랜 잭션에 의해 LOCK이 걸렸을 때 Exception을 만나게 되어 트랜잭션을 종료할 수 있다
        
        → 오히려 동시성 증가
        

## 낙관적 동시성 제어

- 사용자들이 같은 데이터를 동시에 수정하지 않을 것을 가정
- 데이터를 읽을 때, lock을 설정하지 않는다.
- 데이터를 수정하고자 하는 시점에 앞서 읽은 데이터가 다른 사용자에 의해 변경되었는지 체크해야 한다.

**생각해 볼 만한 방법들**

- 데이터 변경할 목적으로 읽으면 당연히 LOCK을 걸어야 한다
- 동시성이 나빠지지 않게 WAIT 또는 NOWAIT 옵션을 활용한 예외처리를 잘하자
- 불필요하게 LOCK을 오래 유지하지 말고, 트랜잭션의 원자성을 보장하는 범위 내에서 가급적 빨리 커밋
- 꼭 주간에 수행할 필요가 없는 배치 프로그램은 야간 시간대에 수행
- 낙관적, 비관적 동시성 제어를 같이 사용하는 방법도 있다. 일단 낙관적 동시성 제어 → 다시 시도할 때 비관적 동시성 제어
- 동시성 향상하고자 할 때 SQL 튜닝은 기본! 효율적인 인덱스 구성, 데이터량에 맞는 조인 메소드 선택할 것
- 적절한 트랜잭션 격리 수준 + Lock 사용
- 공유자원 접근 순서 고정
- 큐 활용
- API GATEWAY에서 처리율 제한장치 구현