# OS / 메모리

# 메모리

> 컴퓨터의 기억장치, CPU도 메모리에 저장된 명령어들을 불러와서 실행하는 장치일 뿐

# 1. 메모리의 계층
![image](https://github.com/CodeWave-Summer-Edition/CSMaster/assets/101088491/3e11952d-0519-4b7a-a9fc-4279b4d45f21)
- 레지스터 : CPU안의 작은 메모리
- 캐시(L1, L2, L3도 있음)
- 메모리(RAM) / 주기억장치
- 저장장치(HDD, SSD) / 보조기억장치

## 캐시

> **데이터를 미리 복사**하는 **임시 저장소**
빠른 장치와 느린 장치의 **속도 차이로 인한 병목 현상**을 줄이기 위한 메모리
> 
- **속도 차이를 해결**하기 위한 계층을 **캐싱 계층**이라고 함

### 지역성

- 캐시를 효율적으로 쓰려면? **자주 사용하는 데이터**를 캐시에 설정해야
- 프로그램은 일반적으로 **시간적**으로나 **공간적**으로 **가까운 데이터에 자주 접근**
- 이걸 각각 **시간 지역성**과 **공간 지역성**이라고 함
    - 한 번 사용한 데이터를 일정시간 캐시에 보관함(시간 지역성)
    - 메모리를 가져올 때, 블록 전체를 가져옴(공간 지역성)

[[Cache] 시간 지역성, 공간 지역성](https://literate-t.tistory.com/73)
```cpp
for (int i = 0; i < 20240; ++i)
	{
		for (int j = 0; j < 20240; ++j)
		{
			matrix[i][j] = 1;
		}
	}
```
```cpp
for (int i = 0; i < 20240; ++i)
	{
		for (int j = 0; j < 20240; ++j)
		{
			matrix[j][i] = 1;
		}
	}
```
- [i][j]로 했을 때와 [j][i]로 했을때, 시간이 4.5배 가량 차이나는 것을 볼 수 있음

## 캐시히트와 캐시미스

> 캐시에서 **원하는 데이터를 찾았다면 캐시히트**
해당 데이터가 **캐시에 없다면 캐시미스**
> 
- 위의 속도 차이도 [i][j]로 하면 캐시히트, [j][i]라면 캐시미스여서 그런듯
![image](https://github.com/CodeWave-Summer-Edition/CSMaster/assets/101088491/5c735778-9638-4522-b7db-140a8b80fac9)
- 캐시히트 → 가까운 캐시에서 내부버스를 통해 가져오니까 빠름
- 캐시미스 → 먼 메모리에서 시스템 버스를 통해 가져오니까 느림

### 캐시 매핑

- CPU가 **캐시에서 데이터를 찾아내는 방식**
- CPU의 레지스터와 주 메모리(RAM) 간에 데이터를 주고받을 때를 기반으로 설명

[[컴퓨터구조] 캐시 메모리 사상(Mapping, 매핑) 방식: 직접사상, 연관사상, 집합 연관사상](https://star7sss.tistory.com/930)

1. 직접 매핑
    - 메모리가 1~100이 있고, 캐시가 1~10이 있다면 1:1~10, 2:1~20 이런 식으로 매핑하는 것
    - 메모리의 각 블록이 캐시의 특정 위치에만 매핑
    - 빠르지만 자주 충돌
2. 연관 매핑
    - 순서를 일치시키지 않고, 관련 있는 캐시와 메모리를 매핑한다.
    - 메모리의 각 블록이 캐시의 어떤 위치에도 매핑 가능
    - 충돌은 적지만 모든 블록을 탐색해야 해서 속도가 느리다.
3. 집합 연관 매핑
    - 직접 매핑 + 연관매핑
    - 캐시를 여러 세트로 나눔 + 각 세트 내에서는 연관 매핑을 사용
    - 빠른 속도 + 충돌 방지

## 웹 브라우저의 캐시

### 쿠키

> 만료 기한이 있는 키-값 저장소
- 보통 사용자의 세션 상태를 유지하거나 사용자의 브라우징 정보를 추적하는 데 사용
    - 모익에서도 로그인 할 때 사용
- 클라이언트 or 서버에서 만료기한을 정할 수 있음(보통 서버)
- 최대 4KB까지 저장 가능

### 로컬 스토리지

> 만료 기한이 없는 키-값 저장소
- 브라우저를 닫아도 계속 유지됨
- 도메인 단위로 생성/저장됨
- 10MB까지 저장 가능, HTML 5 지원 필요, 클라이언트에서만 수정 가능

### 세션 스토리지

> 만료 기한이 있는 키-값 저장소
- 탭을 닫을 때 데이터가 삭제됨
- 5MB까지 저장 가능, HTML 5 지원 필요, 클라이언트에서만 수정 가능

### DB의 캐싱 계층

- **속도 차이를 해결**하기 위한 계층 = **캐싱 계층**
- 메인 DB와 앱 사이에 레디스를 둬서 캐싱 계층으로 사용하기도 함

---

# 2. 메모리 관리

> OS의 대표적인 할일 중 하나, 메모리 짜내기

## 가상 메모리

> 메모리가 실제 메모리보다 많아 보이게 하는 기술
- 초창기에는 RAM의 용량이, 가장 큰 실행 애플리케이션의 주소 공간보다 작다면 “메모리 부족”
- 어떤 프로세스가 실행될 때 메모리에 해당 프로세스 전체가 올라가지 않더라도 실행이 가능함
- 보조 기억장치를 RAM처럼 쓰자!

### 스와핑

- 당장 실행에 필요한 일부분만 메모리에 올리고, 나머지는 보조 기억장치에 놔둠
- 그 때 그 때 실행에 필요한 부분만 올렸다 내렸다 하는 것

### 페이지 폴트

- 요청된 데이터가 현재 메모리에 로드되어 있지 않아 보조 기억장치에서 찾아야 하는 경우 발생
    - 위장전입 ㄷㄷ
- 페이지 폴트가 발생하면 OS는 그 데이터를 메모리로 가져와 마치 페이지 폴트가 발생하지 않은 것처럼 프로그램이 계속 작동하게 해줌.
    
    1) CPU가 물리 메모리에서 해당 데이터가 없는걸 확인하고, 트랩을 통해 OS에 알림
    2) OS가 CPU를 정지시킴
    3) OS가 페이지 테이블을 확인해 가상 메모리에 페이지가 있는지 확인
    - 페이지 : 가상 메모리 시스템에서 메모리를 관리하는 **블록 단위**
    3-1) 없다면 프로세스를 중단하고 물리 메모리에 빈 프레임이 있는지 확인
    3-2) 여기서도 없다면? 스와핑
    4) 비어있는 프레임에 해당 페이지를 로드하고, 페이지 테이블을 최신화
    5) CPU 재실행
    

## 스레싱(thrashing)
> 메모리의 페이지 폴트율이 높아 성능이 저하되는 현상

![image](https://github.com/CodeWave-Summer-Edition/CSMaster/assets/101088491/2a9ab337-a506-40e2-84fa-5b2eb5803782)

- 메모리에 너무 많은 프로세스가 올라가있음 → 많은 스와핑 →  많은 페이지 폴트 → 스레싱
- OS : CPU 이 자식 한가해보이네? 더 일해라
- CPU : 죽여줘…
![image](https://github.com/CodeWave-Summer-Edition/CSMaster/assets/101088491/4eb855b9-9722-411c-b1d6-6a1e46a98502)
- 해결 방안 : 메모리 늘리기, HDD 대신 SSD 쓰기, 작업 세트와 PFF

### 작업 세트

- 지역성을 통해 결정된 페이지 집합을 만들어 미리 메모리에 로드 → 탐색 비용 / 스와핑 감소

### PFF

- 상/하한선을 만들어 페이지 폴트 빈도 조절, 상한선 → 페이지 늘림 / 하한선 → 페이지 줄임

## 메모리 할당

> 메모리에 프로그램을 할당하는 것. **연속할당**과 **불연속할당**이 있음

### 연속할당

> 프로그램이 메모리의 **연속적인 공간에 할당**되는 방식
- 고정 분할 방식 : 메모리를 일정한 크기로 분할하여 각 분할에 하나의 프로그램을 할당
- 가변 분할 방식 : 프로그램의 크기에 맞게 메모리를 동적으로 분할하여 할당

### 불연속할당

> 프로그램을 여러 조각으로 나누어 메모리의 여러 위치에 할당하는 방식
- 페이징 : 메모리를 동일한 크기의 페이지로 분할하여 사용
- 세그멘테이션 : 프로그램을 여러 세그먼트(의미 단위)로 분할하여 각각을 메모리의 다른 위치에 할당
- 돼지를 도축할 때, 페이징은 돼지를 같은 크기로 잘라서 보관하는 것이라면 세그멘테이션은 부위 별로 잘라서 보관한다고 이해
- 페이지드 세그멘테이션 : 페이지와 세그먼테이션의 장점을 모두 취한 방식, 공유나 보안은 세그먼트로, 물리적 메모리는 페이지로 나누어 할당

## 페이지 교체 알고리즘

- 오프라인 알고리즘 : 모든 페이지 참조 정보를 미리 알고 있는 경우, 최적합 알고리즘, 성능 비교 기준
- FIFO : 선입선출, 메모리에 가장 오래된 페이지부터 교체
- LRU : 참조가 가장 오래된 페이지부터 교체
![image](https://github.com/CodeWave-Summer-Edition/CSMaster/assets/101088491/b02b7d6e-b938-49e4-b161-e3adb57e2a50)
- NUR : 최근에 사용되지 않은 페이지부터 교체
- LFU : 가장 참조 횟수가 적은 페이지 교체
