# Join

# [1] 조인의 종류

## 1. 조인이란?

데이터의 중복을 제거하고 무결성을 보장하기 위해 정규화된 (또는 데이터 성격에 따라 분리된) *두 개 이상의 테이블을 묶어서 하나의 결과물을 만드는 것*

- MongoDB의 경우, `$lookup` 을 사용해서 RDBMS의 join 처럼 사용할 수 있다
    - NoSQL 데이터베이스는 보통 정규화를 수행하지 않고, 읽기 성능을 향상시키는 경우가 많음
    - 책에서는 MongoDB의 lookup 연산이 RDBMS의 join보다 성능이 떨어진다고 함

![Untitled](Join%20c9d94cba6d3040c2a10253bf348680c0/Untitled.png)

*참고) MySQL, Oracle 문법 차이

**MySQL**

```sql
select 
    book_id,
    author_name,
    date_format(published_date, '%Y-%m-%d') as published_date
from 
    book
    **join author using (author_id)**
		-- join author on book.author_id = author.author_id
where 
    book.category = '경제'
order by 
    published_date asc;
```

**Oracle**

```sql
select 
    book_id,
    author_name,
    to_char(to_date(published_date), 'YYYY-MM-DD') as published_date
from 
    book, 
		author
where 
    **book.author_id = author.author_id**
    and book.category = '경제'
order by 
    published_date asc;
```

## 2. 조인의 분류

### 2-1. Equi Join

- 두 테이블의 컬럼 값들이 서로 정확하게 일치(`=`)하는 경우에 사용
- 대부분 PK ↔ FK 관계를 기반으로 하나, 꼭 그래야만 하는 것이 아님

### 2-2. Non-Equi Join

- 두 테이블 간 컬럼 값들이 서로 정확하게 일치하지 않는 경우에 사용
- 이 경우 `between A and B`, `>`, `>=`, `<`, `<=` 등의 연산자를 이용해서 join을 수행한다

### 2-3. Inner Join

- join 조건에서 값이 일치하는 행만 반환

### 2-4. Outer Join

- join 조건에서 한쪽 값이 없더라도 행 반환
    - 따라서 equi join이 될 수 없음
- 값이 없는 다른 행은 기본적으로 `null`

## 3. Inner/Outer Join의 종류

### 3-1. (INNER) JOIN

- 두 테이블의 카테시안 곱을 한 결과에서 조인 조건에 맞지 않는 결과들을 모두 제외한 값
    
    ![Untitled](Join%20c9d94cba6d3040c2a10253bf348680c0/Untitled%201.png)
    
    - 실제로 카테시안 곱을 진행하지 않고서 조인 조건에 맞는 값만 반환
- 예시
    
    ```sql
    FROM A INNER JOIN B ON A.w = B.y
    
    /*
    Table A       Table B       Result
    +-------+     +-------+     +---------------+
    | w | x |  *  | y | z |  =  | w | x | y | z |
    +-------+     +-------+     +---------------+
    | 1 | a |     | 2 | k |     | 2 | b | 2 | k |
    | 2 | b |     | 3 | m |     | 3 | c | 3 | m |
    | 3 | c |     | 3 | n |     | 3 | c | 3 | n |
    | 3 | d |     | 4 | p |     | 3 | d | 3 | m |
    +-------+     +-------+     | 3 | d | 3 | n |
                                +---------------+
    */
    ```
    

### 3-2. LEFT (OUTER) JOIN

- 왼쪽 테이블의 값들은 모두 남겨두고 오른쪽에 있는 테이블과 조인하는 연산
    
    ![Untitled](Join%20c9d94cba6d3040c2a10253bf348680c0/Untitled%202.png)
    
    - 왼쪽 테이블에서 조인 조건에 부합하는 값이 없더라도 모두 반환되며, 그 값들은  NULL 로 반환
    - 오른쪽 테이블에서 조인 조건에 부합하는 값이 없으면 제외되어 결과값 반환
- 예시
    
    ```sql
    FROM A LEFT OUTER JOIN B ON A.w = B.y
    
    /*
    Table A       Table B       Result
    +-------+     +-------+     +---------------------------+
    | w | x |  *  | y | z |  =  | w    | x    | y    | z    |
    +-------+     +-------+     +---------------------------+
    | 1 | a |     | 2 | k |     | 1    | a    | NULL | NULL |
    | 2 | b |     | 3 | m |     | 2    | b    | 2    | k    |
    | 3 | c |     | 3 | n |     | 3    | c    | 3    | m    |
    | 3 | d |     | 4 | p |     | 3    | c    | 3    | n    |
    +-------+     +-------+     | 3    | d    | 3    | m    |
                                | 3    | d    | 3    | n    |
                                +---------------------------+
    */
    ```
    

### 3-3. RIGHT (OUTER) JOIN

- 오른쪽 테이블의 값들은 모두 남겨두고 왼쪽에 있는 테이블과 조인하는 연산
    
    ![Untitled](Join%20c9d94cba6d3040c2a10253bf348680c0/Untitled%203.png)
    
    - 오른쪽에 있는 테이블의 값들은 조인 조건에 부합하지 않더라도 모두 반환되며, 그 값들은 NULL 로 반환
    - 왼쪽 테이블의 값들 중 조인 조건에 부합하지 않는 값들은 모두 제외되어 결과값 반환
- 예시
    
    ```sql
    FROM A RIGHT OUTER JOIN B ON A.w = B.y
    
    /*
    Table A       Table B       Result
    +-------+     +-------+     +---------------------------+
    | w | x |  *  | y | z |  =  | w    | x    | y    | z    |
    +-------+     +-------+     +---------------------------+
    | 1 | a |     | 2 | k |     | 2    | b    | 2    | k    |
    | 2 | b |     | 3 | m |     | 3    | c    | 3    | m    |
    | 3 | c |     | 3 | n |     | 3    | c    | 3    | n    |
    | 3 | d |     | 4 | p |     | 3    | d    | 3    | m    |
    +-------+     +-------+     | 3    | d    | 3    | n    |
                                | NULL | NULL | 4    | p    |
                                +---------------------------+
    */
    ```
    

### 3-4. FULL (OUTER) JOIN

- 조인조건에 부합하는 왼쪽, 오른쪽 테이블의 모든 값들을 반환함
    
    ![Untitled](Join%20c9d94cba6d3040c2a10253bf348680c0/Untitled%204.png)
    
    - 만약 한쪽의 값은 조인 조건에 부합하지만 다른 한쪽은 부합하지 않는다면, 부합하지 않는 쪽의 값들은 모두 NULL 로 반환됨
- 예시
    
    ```sql
    FROM A FULL OUTER JOIN B ON A.w = B.y
    
    /*
    Table A       Table B       Result
    +-------+     +-------+     +---------------------------+
    | w | x |  *  | y | z |  =  | w    | x    | y    | z    |
    +-------+     +-------+     +---------------------------+
    | 1 | a |     | 2 | k |     | 1    | a    | NULL | NULL |
    | 2 | b |     | 3 | m |     | 2    | b    | 2    | k    |
    | 3 | c |     | 3 | n |     | 3    | c    | 3    | m    |
    | 3 | d |     | 4 | p |     | 3    | c    | 3    | n    |
    +-------+     +-------+     | 3    | d    | 3    | m    |
                                | 3    | d    | 3    | n    |
                                | NULL | NULL | 4    | p    |
                                +---------------------------+
    */
    ```
    

### 3-5. CROSS JOIN

- from 절에 있는 두 테이블의 카테시안 곱을 반환
    
    ![Untitled](Join%20c9d94cba6d3040c2a10253bf348680c0/Untitled%205.png)
    
    - 즉, 왼쪽 테이블의 모든 row 를 오른쪽 테이블의 모든 row 와 결합하여 반환
    - 따라서 결과값의 행 개수는 `왼쪽 테이블 행 개수 * 오른쪽 테이블 행 개수`
- 예시
    
    ```sql
    FROM A CROSS JOIN B
    -- FROM A, B
    
    /*
    Table A       Table B       Result
    +-------+     +-------+     +---------------+
    | w | x |  *  | y | z |  =  | w | x | y | z |
    +-------+     +-------+     +---------------+
    | 1 | a |     | 2 | c |     | 1 | a | 2 | c |
    | 2 | b |     | 3 | d |     | 1 | a | 3 | d |
    +-------+     +-------+     | 2 | b | 2 | c |
                                | 2 | b | 3 | d |
                                +---------------+
    */
    ```
    

# [2] 조인의 원리

[조인 수행 원리](https://dataonair.or.kr/db-tech-reference/d-guide/sql/?mod=document&uid=356)

[오라클 NL Join, Sort Merge Join, Hash Join 특징 총정리](https://hoon93.tistory.com/46)

## 1. 중첩 루프 조인(NLJ, Nested Loop Join)

- 프로그래밍에서 사용하는 중첩 반복문과 같은 원리로 조인을 수행
- 반복문의 외부에 있는 테이블을 선행/외부 테이블 (Outer Table)이라고 하고, 반복문의 내부에 있는 테이블을 후행/내부 (Inner Table)이라고 함
- outer join 에서 만족하는 레코드가 적을수록 효율이 좋음
- 조인 조건에 해당하는 컬럼들은 `인덱스를 갖고 있어야 함`
- 랜덤 액세스 방식으로 데이터를 읽음
    - 인덱스 스캔은 NL조인 방식으로 조인을 수행함
    - 랜덤 접근에 대한 비용이 많이 증가하므로 대용량 테이블에서는 사용하지 않음
- 조인을 한 row 씩 순차적으로 진행함
- 인덱스 구성 전략이 특히 중요
    - 조인 컬럼에 대한 인덱스가 있는지 없는지
    - 있으면 컬럼이 어떻게 구성되어있는지에 따라 조인 효율이 크게 달라짐
- 소량의 데이터를 주로 처리하거나, 부분 범위 처리가 가능한 온라인 트랜잭션 환경에 적합한 조인 방식
+) 조인이 성공하면 바로 조인 결과를 사용자에게 보여줄 수 있어, 결과를 가능한 빨리 보여줘야 하는 온라인 프로그램에 적합
- NL Join 과정
    
    *추출 버퍼는 SQL문 실행 결과를 보관하는 버퍼로, 일정 크기를 설정해서 추출 버퍼에 결과가 모두 차거나 더이상 결과가 없으면 추출 버퍼 내 결과를 사용자에게 반환
    
    ![Untitled](Join%20c9d94cba6d3040c2a10253bf348680c0/Untitled%206.png)
    
    ① 선행 테이블에서 조건을 만족하는 첫 번째 행을 찾음 → 이때 선행 테이블에 주어진 조건을 만족하지 않는 경우 해당 데이터는 필터링 됨
    
    ② 선행 테이블의 조인 키를 가지고 후행 테이블에 조인 키가 존재하는지 찾으러 감 → 조인 시도 
    
    ③ 후행 테이블의 인덱스에 선행 테이블의 조인 키가 존재하는지 확인 → 선행 테이블의 조인 값이 후행 테이블에 존재하지 않으면 선행 테이블 데이터는 필터링 됨 (더 이상 조인 작업을 진행할 필요 없음) 
    
    ④ 인덱스에서 추출한 레코드 식별자를 이용하여 후행 테이블을 액세스 → 인덱스 스캔을 통한 테이블 액세스 후행 테이블에 주어진 조건까지 모두 만족하면 해당 행을 추출버퍼에 넣음 
    
    ⑤ ~ ⑪ 앞의 작업을 반복 수행
    

### 1-1. Block Nested Loop Join

*~~이런 게 있었단다~~~*

- 인덱스가 없는 환경에서 활용 가치가 높은 조인
- 선행 테이블을 조인 버퍼에 적재해두고, 후행 테이블에서 탐색한 결과 집합을 결합하는 방식으로 작동
- 후행 테이블의 접근 횟수를 줄여서 전체 쿼리 성능을 높이는 방식

→ MySQL 8.0.18 버전 이후 BNL 조인 대신 해시 조인을 사용한다고 함

## 2. 정렬 병합 조인 (Sort Merge Join)

- 조인 컬럼을 기준으로 데이터를 정렬하고, 정렬이 끝난 이후에 조인 수행
    - 그러나 조인 작업을 위해 항상 정렬 작업이 발생하지는 않음 (이미 앞 단계의 작업을 수행하던 중에 정렬이 수행되었다면 등)
- 주로 Full Table Scan 방식으로 데이터를 읽음
    - 랜덤 액세스로는 NLJ 에서 부담이 되던 넓은 범위의 데이터를 처리할 때 이용되던 기법
    - 그러나 정렬할 데이터가 많아 메모리에서 모든 정렬 작업을 수행하기 어려운 경우 디스크를 사용하기 때문에 성능이 떨어질 수 있음
    - 그래서 일반적으로 CPU 작업 위주로 처리하는 Hash Join이 성능상 유리하지만, 정렬 병합 조인은 해시 조인과 달리 Non-equi 조인에 대해서도 조인이 가능함
- 정렬 병합 조인 과정
    
    ![Untitled](Join%20c9d94cba6d3040c2a10253bf348680c0/Untitled%207.png)
    
    ① 선행 테이블에서 주어진 조건을 만족하는 행을 찾음 
    
    ② 선행 테이블의 조인 키를 기준으로 정렬 작업을 수행 
    
    ① ~ ②번 작업을 선행 테이블의 조건을 만족하는 모든 행에 대해 반복 수행 
    
    ③ 후행 테이블에서 주어진 조건을 만족하는 행을 찾음 
    
    ④ 후행 테이블의 조인 키를 기준으로 정렬 작업을 수행 
    
    ③ ~ ④번 작업을 후행 테이블의 조건을 만족하는 모든 행에 대해 반복 수행 
    
    ⑤ 정렬된 결과를 이용하여 조인을 수행하며 조인에 성공하면 추출버퍼에 넣음
    

## 3. 해시 조인

[Hash Join](https://genote.tistory.com/13)

- 해싱 기법을 이용해 조인 수행
    - 조인을 수행할 테이블의 조인 컬럼을 기준으로 해시 함수를 수행하여, 서로 동일한 해시 값을 갖는 것들 사이에서 실제 값이 같은지를 비교하면서 조인 수행
- NL조인의 랜덤 액세스 문제점과 Sort Merge Join의 정렬 작업 부담을 해결하기 위해 만들어짐
- 조인 컬럼의 인덱스를 사용하지 않기 때문에 조인 컬럼의 인덱스가 없어도 사용 가능함
- 해시 함수를 이용하여 조인을 수행하기 때문에 Equi Join에서만 사용 가능함
    - 해시 함수를 적용한 값은 어떤 값으로 해싱될지 알 수 없으나, 해시 함수가 적용될 때 동일한 값은 항상 같은 값으로 해싱되는 것은 보장
    - 그러나 큰 값은 항상 큰 값으로, 작은 값은 항상 작은 값으로 해싱된다는 보장은 없음
- 결과 행의 수가 적은 테이블을 선행 테이블로 사용하는 것이 좋음
    - 생성된 해시 테이블의 크기가 메모리에 적재할 수 있는 크기보다 커지면 디스크에 해시 테이블을 저장하기 때문
    - 만약 선행 테이블의 결과를 완전히 메모리에 저장할 수 있으면 디스크에 저장하는 작업 X
- 해시 조인 과정
    
    ![Untitled](Join%20c9d94cba6d3040c2a10253bf348680c0/Untitled%208.png)
    
    ① 선행 테이블에서 주어진 조건을 만족하는 행을 찾음 
    
    ② 선행 테이블의 조인 키를 기준으로 해쉬 함수를 적용하여 해쉬 테이블을 생성 → 조인 칼럼과 SELECT 절에서 필요로 하는 칼럼도 함께 저장됨 
    
    ① ~ ②번 작업을 선행 테이블의 조건을 만족하는 모든 행에 대해 반복 수행 
    
    ③ 후행 테이블에서 주어진 조건을 만족하는 행을 찾음 
    
    ④ 후행 테이블의 조인 키를 기준으로 해쉬 함수를 적용하여 해당 버킷을 찾음 → 조인 키를 이용해서 실제 조인될 데이터를 찾음 
    
    ⑤ 조인에 성공하면 추출버퍼에 넣음 
    
    ③ ~ ⑤번 작업을 후행 테이블의 조건을 만족하는 모든 행에 대해서 반복 수행
    

### 3-1. 빌드 단계

- 작은 쪽 테이블을 읽어 해시 테이블을 생성하는 단계
- 조인에 사용되는 컬럼이 인메모리 해시 테이블의 키로 사용됨
    - 해당 컬럼을 해시 함수에 입력하면 반환된 값으로 해시 체인을 찾고, 그 해시 체인에 데이터를 연결함
    - 해시 테이블은 PGA 영역에 할당된 Hash Area에 저장하고, 만약 해시 테이블이 너무 커서 PGA(메모리)에 저장이 불가능하면 Temp 테이블스페이스(디스크)에 저장한다
    - 해시테이블에는 조인 키 값과 SQL에 사용한 컬럼을 모두 저장한다
- PGA란?
    
    ![Untitled](Join%20c9d94cba6d3040c2a10253bf348680c0/Untitled%209.png)
    

### 3-2. 프로브 단계

- 큰 테이블을 읽어 해시 테이블을 탐색하면서 조인하는 단계
- 기준 컬럼을 해시 함수에 입력해서 반환된 값으로 해시 체인을 찾고, 그 해시 체인을 스캔해서 값이 같은 것을 찾음
    - 찾으면 조인 성공
    - 못 찾으면 실패
    - 기본적으로 NL 조인과 같음

### 3-3. 대용량 build input 처리

- 조인하려는 두 개의 테이블이 모두 대용량으로 인메모리 해시 조인이 불가능한 경우 divide & conquer 방식을 사용한다
- divide (파티션 단계)
    - 조인 대상 집합의 조인 컬럼에 해시 함수를 적용하고, 반환된 해시 값에 따라 동적으로 파티셔닝한다
    - 독립적으로 처리할 수 있는 여러개의 작은 서브집합으로 분할하여 파티션을 생성하는 단계
    - 양쪽 집합을 읽어 디스크에 저장해야 하므로 인메모리 해시 조인보다 성능이 떨어진다
- conquer (조인 단계)
    - 파티션 단계에서 만든 pair 에 대해 하나씩 조인 수행
    - 이 때 두 개의 파티션 중 더 작은 쪽이 build input, 큰 쪽이 probe input 으로 결정됨 (테이블의 크기와는 무관)
    - build input 으로 해시 테이블을 생성하고, 반대쪽 파티션 row를 하나씩 읽으면서 해시 테이블을 탐색